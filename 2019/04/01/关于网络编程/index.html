<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>关于网络编程 | 南城逆流的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于网络编程</h1><a id="logo" href="/.">南城逆流的博客</a><p class="description">From small beginnings comes great things</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/pad/"><i class="fa fa-pad"> 留言</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于网络编程</h1><div class="post-meta">Apr 1, 2019<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h5 id="一、网络通信协议："><a href="#一、网络通信协议：" class="headerlink" title="一、网络通信协议："></a>一、网络通信协议：</h5><p>虽然通过计算机网络可以使多台计算机连接，但是位于同一个网络中的计算机在进行连接和通信时必须遵守一定的规则，这些连接和通信的规则被称为网络通信协议；</p>
<p>网络通信协议有多种，目前应用最广泛的就是Tcp/Ip协议，网络编程也是基于Tcp/Ip协议中的内容，tcp/ip协议是一组用于实现网络互联的通信协议其参考模型如下：</p>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=979153248,1387570633&amp;fm=26&amp;gp=0.jpg" alt="img"></p>
<ul>
<li>网络接口层：主要负责监视数据在主机和网络之间的交换。</li>
<li>网络层：是整个tcp/ip协议的核心主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li>传输层：主要使网络程序进行通信，在进行通讯时，可采用tcp协议或者udp协议。</li>
<li>应用层：主要负责应用程序的协议，例如：http协议，ftp协议；</li>
</ul>
<h5 id="二、ip地址和端口号："><a href="#二、ip地址和端口号：" class="headerlink" title="二、ip地址和端口号："></a>二、ip地址和端口号：</h5><p>1.要想使网络中的计算机能够通信，必须为每台计算机指定一个标识符，通过这个标识符来指定接受数据的计算机或者发送数据的计算机，在tcp/ip协议中这个标识符就是这个ip地址；它可以唯一标识一台计算机。</p>
<p>ip地址现在分为 ipv4和ipv6.使用最广泛的是ipv4,但是随着网络规模的不断扩大，iPv4这种4个字节表示的ip地址将面临着使用枯竭，所以ipv6解决了网络地址资源数量不足的问题；</p>
<p>ip地址由两部分组成，即“网络.主机”，ip地址总共分为5类，常用的有3类即 a类，b类， c类。</p>
<p>2.端口号：唯一的代表了这台机上的某个应用程序；在计算机中。不同的应用程序用端口号来区分。</p>
<p>3.域名：由于IP地址不方便记忆，所以有专门创造了域名(Domain Name)的概念，其实就是给IP取一个字符的名字，例如163.com、sina.com等。IP和域名之间存在一定的对应关系。如果把IP地址类比成身份证号的话，那么域名就是你的姓名。</p>
<p>4.DNS：其实在网络中只能使用IP地址进行数据传输，所以在传输以前，需要把域名转换为IP，这个由称作DNS的服务器专门来完成。 所以在网络编程中，可以使用IP或域名来标识网络上的一台设备。</p>
<a id="more"></a>
<h5 id="三、java-net-InetAddress类的使用"><a href="#三、java-net-InetAddress类的使用" class="headerlink" title="三、java.net.InetAddress类的使用"></a>三、java.net.InetAddress类的使用</h5><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string  getHostName()</td>
<td>得到ip地址的主机名，如果没有域名则是ip地址</td>
</tr>
<tr>
<td>String  getHostAddress()</td>
<td>该方法用来得到主机的IP地址，这个IP地址可以是IPv4也可以是IPv6的</td>
</tr>
<tr>
<td>boolean isReachable(int timeout)</td>
<td>判断指定时间内地址是否可以到达</td>
</tr>
<tr>
<td>InetAddress getByName(String host)</td>
<td>该方法用于给定主机名 的情况下确定主机的ip地址</td>
</tr>
<tr>
<td>InetAddress getLocalHost()</td>
<td>创建本机的inetAddress对象</td>
</tr>
</tbody>
</table>
<p>  1、用 getLocalHost() 方法创建的InetAddress的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address=InetAddress.getLocalHost();</span><br><span class="line">System.out.println(address.getHostName());<span class="comment">//返回本机名</span></span><br></pre></td></tr></table></figure>
<p>2、 用域名创建 InetAddress对象</p>
<p>用域名作为getByName和getAllByName方法的参数得到的InetAddress对象，该对象会得到这个域名，当调用getHostName时，就无需再访问DNS服务器，而是<strong>直接将这个域名返回</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address=InetAddress.getByName(<span class="string">"ZZQ"</span>);</span><br><span class="line">System.out.println(address.getHostName());<span class="comment">//不必再访问DNS服务器，直接返回域名</span></span><br></pre></td></tr></table></figure>
<p>3、用IP地址创建 InetAddress对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address=InetAddress.getByName(<span class="string">"141.146.8.66"</span>);  </span><br><span class="line">System.out.println(address.getHostName());<span class="comment">//需要访问DNS服务器才能得到域名  </span></span><br><span class="line">InetAddress address=InetAddress.getByName(<span class="string">"1.2.3.4"</span>);<span class="comment">//IP地址不存在  </span></span><br><span class="line">System.out.println(address.getHostName());<span class="comment">//直接返回IP地址</span></span><br></pre></td></tr></table></figure>
<h5 id="四、udp与tcp协议"><a href="#四、udp与tcp协议" class="headerlink" title="四、udp与tcp协议"></a>四、udp与tcp协议</h5><table>
<thead>
<tr>
<th>udp</th>
<th>tcp</th>
</tr>
</thead>
<tbody>
<tr>
<td>无连接的通信协议</td>
<td>面向连接的通信协议</td>
</tr>
<tr>
<td>数据传输时，数据的发送端和接收端不建立连接</td>
<td>数据传输前先在发送端和接收端建立连接</td>
</tr>
<tr>
<td>是基于数据报的</td>
<td>面向字节流的</td>
</tr>
<tr>
<td>可能丢包，不能保证数据的完整性</td>
<td>保证数据正确性</td>
</tr>
<tr>
<td>不保证数据顺序</td>
<td>保证数据顺序</td>
</tr>
<tr>
<td>不可靠协议速度快</td>
<td>可靠协议，速度稍低</td>
</tr>
<tr>
<td>首部开销20字节</td>
<td>首部开销8字节</td>
</tr>
<tr>
<td>点对点</td>
<td>一对一，一对多，多对多</td>
</tr>
<tr>
<td>qq语音，qq视频</td>
<td>文件传输，打电话</td>
</tr>
</tbody>
</table>
<h5 id="五、socket"><a href="#五、socket" class="headerlink" title="五、socket:"></a>五、socket:</h5><p>就是为网络服务提供的一种机制；</p>
<p>——–通信的两端都有Socket；</p>
<p>———网络通信其实就是Socket建的通信；</p>
<p>———数据再两个Socket间通过 IO 传输。</p>
<p>———也可以这样理解：Socket就像连接航线两端的港口。</p>
<h5 id="六：udp通讯；"><a href="#六：udp通讯；" class="headerlink" title="六：udp通讯；"></a>六：udp通讯；</h5><p><strong>原理：</strong></p>
<ul>
<li>Udp传输技术基于 <strong>DatagramSocket</strong> 与 <strong>DatagramPacket</strong>对象；</li>
<li>建立发送端、接收端；</li>
<li>建立数据包；</li>
<li>调用Socket的发送接收方法；</li>
<li>关闭Socket；</li>
<li>发送端和接收端是两个独立的运行程序；</li>
</ul>
<p>1： DateGramPacket类，就像一个集装箱，用于封装udp通讯中发送或者接受的数据。<strong>接收端的构造方法：</strong>只需要接受一个字节数组来存放接受到的数据。<strong>发送端的构造方法</strong>：不但要接受存放的数据的字节数组，还要指定ip和端口号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataGramPacket(<span class="keyword">byte</span>[] buf ,<span class="keyword">int</span> length)<span class="comment">//接收端</span></span><br><span class="line">DataGramPacket(<span class="keyword">byte</span>[] buf ,<span class="keyword">int</span> length,InetAddress addr,<span class="keyword">int</span> port）<span class="comment">//发送端</span></span><br><span class="line"><span class="comment">//常用方法;</span></span><br><span class="line"><span class="function">InetAddress <span class="title">getAddress</span><span class="params">()</span><span class="comment">//该方法用于返回发送端或者接收端的ip地址，如果是发送端的DatagramSocket就返回接送端的ip地址</span></span></span><br><span class="line"><span class="function">Int <span class="title">getPort</span><span class="params">()</span><span class="comment">//，用于返回发送端或者接收端的端口；如果是发送端的DatagramSocket就返回接送端的端口号；</span></span></span><br><span class="line"><span class="function">Byte[] <span class="title">getData</span><span class="params">()</span><span class="comment">//该方法用于返回将要接收或者将要发送的数据如果是发送端的DatagramSocket就返回发送端的数据；</span></span></span><br></pre></td></tr></table></figure>
<p>2：DataGramSocket类：就像一个码头，使用这个类可以发送和接受DataGrampacket数据包，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataGramSocket()<span class="comment">//创建发送端的DataGramSocket对象,没有指定端口号，系统会自动分配一个端口号</span></span><br><span class="line">DataGramSocket(<span class="keyword">int</span> port)<span class="comment">//既可以用于发送，又可以用于接收端</span></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DataGramPacket p)</span><span class="comment">//将接受到数据填充到DataGramPacket数据包中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DataGramPacket p)</span><span class="comment">//该方法用于发送DataGramPacket数据包，</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span><span class="comment">//关闭当前socket</span></span></span><br></pre></td></tr></table></figure>
<p>3：接受端代码编写;</p>
<p>为了防止发送 端发送数据时而找不到接受端而造成数据丢失问题，所以需要先完成接收端程序编写；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：定义一个应用程序，用于接收Udp协议传输的数据并处理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1、定义UdpSocket服务，并监听一个端口；</span></span><br><span class="line"><span class="comment"> * 2、定义个数据包，因为要存储接收到的字节数据--数据包对象中封装了提取字节数据信息的方法；</span></span><br><span class="line"><span class="comment"> * 3、通过Socket服务的receive方法将收到的数据存入已定义好的数据包中；</span></span><br><span class="line"><span class="comment"> * 4、通过数据包对象的特有功能，将这些不同的数据去除，打印在控制台上；</span></span><br><span class="line"><span class="comment"> * 5、关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Udpreceive</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1.创建UdpSocket,建立端点</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">11010</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2、定义数据包用于存储数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * DatagramPacket(byte[] buf, int length) </span></span><br><span class="line"><span class="comment">                  构造 DatagramPacket，用来接收长度为 length 的数据包。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf,buf.length);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3、通过数服务的receive方法，将收到的数据存入数据包中</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//4、通过数据包的方法获取其中的数据</span></span><br><span class="line">            String ip = dp.getAddress().getHostAddress();</span><br><span class="line">            System.out.println(ip + <span class="string">"..........is connected"</span>);</span><br><span class="line">            String data = <span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength());<span class="comment">//只打印接收数据的长度，不打印全部缓冲流</span></span><br><span class="line">            System.out.println(data);</span><br><span class="line">            <span class="keyword">int</span> port = dp.getPort();</span><br><span class="line">            System.out.println(<span class="string">"port:"</span> + port);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//5、关闭资源</span></span><br><span class="line">            ds.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.发送端代码编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：通过Udp传输方式，将一段文字数据发送 出去；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1、建立UdpSocket服务；</span></span><br><span class="line"><span class="comment"> * 2、提供数据，并将数据封装到数据包中；</span></span><br><span class="line"><span class="comment"> * 3、通过Socket服务的发送功能，将数据包发出去</span></span><br><span class="line"><span class="comment"> * 4、关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpSend</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//1、创建Udp服务，通过DatagramSocket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、确定数据，并封装成数据包</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="string">"hello,word"</span>.getBytes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*DatagramPacket(byte[] buf, int length, InetAddress address, int port) </span></span><br><span class="line"><span class="comment">              构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf,buf.length,InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">11010</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//3、通过Socket服务，将已有的数据包发送出去，通过send方法</span></span><br><span class="line">         ds.send(dp);</span><br><span class="line">         </span><br><span class="line">         Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">         <span class="comment">//4、关闭资源</span></span><br><span class="line">         ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span>.0.1..........is connected</span><br><span class="line">hello,word</span><br><span class="line">port:<span class="number">52793</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.net.SocketException: Socket closed</span><br><span class="line">    at java.net.PlainDatagramSocketImpl.receive0(Native Method)</span><br><span class="line">    at java.net.PlainDatagramSocketImpl.receive(PlainDatagramSocketImpl.java:<span class="number">136</span>)</span><br><span class="line">    at java.net.DatagramSocket.receive(DatagramSocket.java:<span class="number">725</span>)</span><br><span class="line">    at com.shindo.java.udp.Udpreceive.main(Udpreceive.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure>
<p>//发送端从键盘输入信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.udp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：实现发送信息的键盘录入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpSendKeyboard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        BufferedReader bufr = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = bufr.readLine()) != <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"byebye"</span>.equals(line)) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">byte</span>[] buf = line.getBytes();</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf,buf.length,InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">11010</span>);</span><br><span class="line">            </span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="七、tcp通信；"><a href="#七、tcp通信；" class="headerlink" title="七、tcp通信；"></a>七、tcp通信；</h5><p>tcp通讯原理：</p>
<ul>
<li>1.分为客户端和服务器端，通讯时必须先由客户端先去连接服务器才能实现通讯， 服务器端不可以主动联系客户端，并且服务器端必须先启动；</li>
<li>2.依赖于：ServerSocket类，表示服务器端和socket类，用于表示客户端。</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/1189312/201709/1189312-20170916130334297-694676605.png" alt="img"></p>
<p>1.ServerSocket类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket()</span><br><span class="line">ServerSocket(<span class="keyword">int</span> port)</span><br><span class="line">ServerSocket(<span class="keyword">int</span> port,<span class="keyword">int</span> backlog)<span class="comment">//backlog用于指定在服务器忙的时，可以与之保持连接请求的等待客户数量，默认50；</span></span><br><span class="line">ServerSocket()</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="function">Socket <span class="title">accept</span><span class="params">()</span><span class="comment">//该方法用于等待客户端连接。返回一个socket对象。</span></span></span><br><span class="line"><span class="function">InetAddress <span class="title">getInetAddress</span><span class="params">()</span><span class="comment">//用于返回一个inetAddress对象，该对象封装serverSocket绑定的地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClose</span><span class="params">()</span><span class="comment">//判断服务器是否关闭；</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bin</span><span class="params">(SocketAddess endpoint)</span><span class="comment">//用于将serverSocket对象绑定到指定的ip地址和端口号</span></span></span><br></pre></td></tr></table></figure>
<p>2.socket类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket();</span><br><span class="line">socket(String host,<span class="keyword">int</span> port);</span><br><span class="line">socket(InetAddress address,<span class="keyword">int</span> port);</span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span><span class="comment">//返回socket对象与服务器端连接的端口号</span></span></span><br><span class="line"><span class="function">InetAddress <span class="title">getLocalAddress</span><span class="params">()</span><span class="comment">//该方法用于获取Socket对象绑定的本地ip地址</span></span></span><br><span class="line"><span class="function">Void <span class="title">close</span><span class="params">()</span><span class="comment">//关闭sockcet连接</span></span></span><br><span class="line"><span class="function">InPutStream <span class="title">getInputStream</span><span class="params">()</span><span class="comment">//如果该对象是由服务器端Socket返回，就用于读取客户端发送的数据；</span></span></span><br><span class="line"><span class="function">outPutStream <span class="title">getOutPutStream</span><span class="params">()</span><span class="comment">//如果该对象是由服务器端Socket返回，就用于向客户端发送数据；</span></span></span><br></pre></td></tr></table></figure>
<p>3.服务器端代码编写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：定义端点接收数据，并打印在控制台上</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、建立ServerSocket服务，并监听一个端口</span></span><br><span class="line"><span class="comment"> * 2、获取连接过来的客户端对象</span></span><br><span class="line"><span class="comment"> *    通过ServerSocket的accept()方法，没有连接就会等，所以这个方法是阻塞的。</span></span><br><span class="line"><span class="comment"> * 3、客户端如果发过来数据，那么服务端要使用对应的客户端对象，并获取到该客户端对象的读取流</span></span><br><span class="line"><span class="comment"> *  来读取客户端发送过来的数据，并打印控制台；</span></span><br><span class="line"><span class="comment"> * 4、关闭服务端（可选）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//建立服务端Socket服务，并监听一个端口</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">11012</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过accept()方法获取连接过来的客户端对象</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        </span><br><span class="line">        String ip = s.getInetAddress().getHostAddress();</span><br><span class="line">        System.out.println(ip + <span class="string">".........is connected"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用客户端对象的读取流读取客户端发送过来的数据</span></span><br><span class="line">        InputStream in = s.getInputStream();<span class="comment">//实际上是一个网络流</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">        </span><br><span class="line">        s.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.客户端代码编写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * 通过查询Socket对象，发现在该对象建立时，就可以去连接指定的主机，</span></span><br><span class="line"><span class="comment"> * 因为Tcp是面向连接的，所以在建立Socket服务时，就要有服务端存在，并连接成功，形成通路后，在该通道进行数据传输</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 需求：给服务端发送一个文本数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建客户端的Socket服务，指定目的主机和端口</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">11012</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为了发送数据，应获取Socket流中的输出流</span></span><br><span class="line">        OutputStream out = s.getOutputStream();<span class="comment">//使用字节流</span></span><br><span class="line">        </span><br><span class="line">        out.write(<span class="string">"This's the first Tcp test Demo"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为流是通过Socket获得的，所有一旦Socket关闭，流也随之关闭</span></span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>上面这两个例子，实现了客户端向服务端发送文本信息，服务端收到并将其打印到控制台。</p>
<p>=========================================================================</p>
<p>现在我们再对上面两个程序进行一些改造，让服务端接收到客户端的信息后，打印到控制台，并响应信息给客户端；客户端也将服务端响应的信息打印到控制台：</p>
<p>服务器端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端，并监听一个端口</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">11012</span>);</span><br><span class="line">            Socket s = ss.accept();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取请求的客户端ip，并打印控制台</span></span><br><span class="line">            String ip = s.getInetAddress().getHostAddress();</span><br><span class="line">            System.out.println(ip + <span class="string">"........... is connected"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取客户端发送过来的数据，并打印控制台</span></span><br><span class="line">            InputStream in = s.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送响应信息给客户端</span></span><br><span class="line">            OutputStream out = s.getOutputStream();</span><br><span class="line">            out.write(<span class="string">"welcome, client !"</span>.getBytes());</span><br><span class="line">            </span><br><span class="line">            s.close();</span><br><span class="line">            ss.close();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shindo.java.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClient2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket s = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">11012</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//发送文本数据给客户端</span></span><br><span class="line">            OutputStream out = s.getOutputStream();</span><br><span class="line">            out.write(<span class="string">"This's the better TcpClient test Demo"</span>.getBytes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//读取客户端响应信息</span></span><br><span class="line">            InputStream in = s.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = in.read(buf);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf,<span class="number">0</span>,len));</span><br><span class="line">            </span><br><span class="line">            s.close();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运次结果：</p>
<p>//客户端</p>
<p><img src="https://images2015.cnblogs.com/blog/617148/201603/617148-20160320103705021-576085840.png" alt="img"></p>
<p>//服务端</p>
<p><img src="https://images2015.cnblogs.com/blog/617148/201603/617148-20160320103742646-376557665.png" alt="img"></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>圈圈</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/04/01/关于网络编程/">http://yoursite.com/2019/04/01/关于网络编程/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a class="next" href="/2019/03/26/常用正则表达式/">常用正则表达式</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC80MzQ3NC8yMDAxNA=="></div><script>(function(d, s) {
     var j, e = d.getElementsByTagName(s)[0];
     if (typeof LivereTower === 'function') { return; }
     j = d.createElement(s);
     j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
     j.async = true;
     e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script><script src="//cdn1.lncld.net/static/js/3.5.0/av-min.js"></script><script src="//unpkg.com/valine@1.1.9-beta3/dist/Valine.min.js"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/java/" style="font-size: 15px;">java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/01/关于网络编程/">关于网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/26/常用正则表达式/">常用正则表达式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="百度" target="_blank">百度</a><ul></ul><a href="http://www.atguigu.com/" title="尚硅谷" target="_blank">尚硅谷</a><ul></ul><a href="https://www.w3cschool.cn/" title="w3c" target="_blank">w3c</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">南城逆流的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>